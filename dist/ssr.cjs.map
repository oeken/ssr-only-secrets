{"version":3,"sources":["../src/ssr.ts","../src/shared.ts"],"sourcesContent":["import { wrap } from \"optimism\";\nimport { deserialize, getEncryptionKey } from \"./shared.js\";\nimport { use } from \"react\";\n\n/**\n * Decrypts a secret that was created in a Server Component using\n * `cloakSSROnlySecret`.\n *\n * Calling this in a Browser environment will always return `undefined`.\n *\n * Only available in Client Components.\n *\n * @public\n */\nexport async function readSSROnlySecret(\n  cloakedSecret: string | undefined,\n  encryptionEnvVarName: string\n): Promise<string | undefined> {\n  if (cloakedSecret == undefined) {\n    return undefined;\n  }\n  const key = await getEncryptionKey(encryptionEnvVarName);\n  const [crypt, iv] = deserialize(cloakedSecret);\n\n  const decrypted = await crypto.subtle.decrypt(\n    {\n      name: \"AES-CBC\",\n      iv: iv,\n    },\n    key,\n    crypt\n  );\n\n  return new TextDecoder().decode(decrypted);\n}\n\n/**\n * We need to memoize the promises returned from `readSSROnlySecret` to avoid\n * an infinite render circle with `use`.\n * We use the `optimism` package for this.\n * We assume that `10000` is a reasonable maximum number of secrets that will be\n * read simultaneously, but this value might need increasing in the future depending\n * on how this is used.\n */\nconst memoizedReadSSROnlySecret = wrap(readSSROnlySecret, {\n  max: 10000,\n}) as any as typeof readSSROnlySecret;\n\n/**\n * Decrypts a secret that was created in a Server Component using\n * `cloakSSROnlySecret`.\n * If called during SSR, this hook will briefly suspend your component and\n * then return the decrypted secret.\n *\n * Calling this in a Browser environment will always return `undefined`.\n *\n * Only available in Client Components.\n *\n * @public\n */\nexport function useSSROnlySecret(\n  cloakedSecret: string | undefined,\n  encryptionEnvVarName: string\n): string | undefined {\n  const promise = memoizedReadSSROnlySecret(\n    cloakedSecret,\n    encryptionEnvVarName\n  );\n  return use(promise);\n}\n","export function getEncryptionKey(envVarName: string): Promise<CryptoKey> {\n  if (envVarName == undefined) {\n    throw new Error(\n      \"You need to specify the name for a secret-holding environment variable.\"\n    );\n  }\n  if (envVarName.startsWith(\"NEXT_PUBLIC_\")) {\n    throw new Error(\n      \"You cannot use NEXT_PUBLIC_ environment variables for secrets, as they would be transported to the browser.\"\n    );\n  }\n  const encryption_key = process.env[envVarName];\n  if (!encryption_key) {\n    throw new Error(\n      \"There is no environment variable named \" + envVarName + \".\"\n    );\n  }\n  let parsed: JsonWebKey;\n  try {\n    const buffer = Buffer.from(encryption_key, \"base64\");\n    const decodedKey = buffer.toString(\"utf8\");\n    parsed = JSON.parse(decodedKey);\n  } catch {\n    throw new Error(\n      \"The environment variable \" +\n        envVarName +\n        \" does not contain a valid JSON string.\"\n    );\n  }\n  return crypto.subtle.importKey(\"jwk\", parsed, \"AES-CBC\", false, [\n    \"encrypt\",\n    \"decrypt\",\n  ]);\n}\n\nexport function serialize(crypt: ArrayBuffer, iv: Uint8Array) {\n  return (\n    Buffer.from(crypt).toString(\"base64\") +\n    \":\" +\n    Buffer.from(iv).toString(\"base64\")\n  );\n}\n\nexport function deserialize(serialized: string) {\n  const [crypt, iv] = serialized.split(\":\");\n  return [\n    Buffer.from(crypt, \"base64\"),\n    Uint8Array.from(Buffer.from(iv, \"base64\")),\n  ] as const;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;;;ACAd,SAAS,iBAAiB,YAAwC;AACvE,MAAI,cAAc,QAAW;AAC3B,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,MAAI,WAAW,WAAW,cAAc,GAAG;AACzC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,iBAAiB,QAAQ,IAAI,UAAU;AAC7C,MAAI,CAAC,gBAAgB;AACnB,UAAM,IAAI;AAAA,MACR,4CAA4C,aAAa;AAAA,IAC3D;AAAA,EACF;AACA,MAAI;AACJ,MAAI;AACF,UAAM,SAAS,OAAO,KAAK,gBAAgB,QAAQ;AACnD,UAAM,aAAa,OAAO,SAAS,MAAM;AACzC,aAAS,KAAK,MAAM,UAAU;AAAA,EAChC,QAAQ;AACN,UAAM,IAAI;AAAA,MACR,8BACE,aACA;AAAA,IACJ;AAAA,EACF;AACA,SAAO,OAAO,OAAO,UAAU,OAAO,QAAQ,WAAW,OAAO;AAAA,IAC9D;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAUO,SAAS,YAAY,YAAoB;AAC9C,QAAM,CAAC,OAAO,EAAE,IAAI,WAAW,MAAM,GAAG;AACxC,SAAO;AAAA,IACL,OAAO,KAAK,OAAO,QAAQ;AAAA,IAC3B,WAAW,KAAK,OAAO,KAAK,IAAI,QAAQ,CAAC;AAAA,EAC3C;AACF;;;AD/CA,mBAAoB;AAYpB,eAAsB,kBACpB,eACA,sBAC6B;AAC7B,MAAI,iBAAiB,QAAW;AAC9B,WAAO;AAAA,EACT;AACA,QAAM,MAAM,MAAM,iBAAiB,oBAAoB;AACvD,QAAM,CAAC,OAAO,EAAE,IAAI,YAAY,aAAa;AAE7C,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IACpC;AAAA,MACE,MAAM;AAAA,MACN;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,IAAI,YAAY,EAAE,OAAO,SAAS;AAC3C;AAUA,IAAM,gCAA4B,sBAAK,mBAAmB;AAAA,EACxD,KAAK;AACP,CAAC;AAcM,SAAS,iBACd,eACA,sBACoB;AACpB,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,EACF;AACA,aAAO,kBAAI,OAAO;AACpB;","names":[]}