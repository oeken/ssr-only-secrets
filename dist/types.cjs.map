{"version":3,"sources":["../src/types.ts","../src/ssr.ts","../src/shared.ts","../src/rsc.ts"],"sourcesContent":["/**\n * This package provides a way to pass secrets from Server Components into the\n * SSR-run of Client Components without them being accessible in the browser.\n * \n * This technique was inspired by {@link https://github.com/apollographql/apollo-client-nextjs/issues/85#issuecomment-1753442277 | this comment} by {@link https://github.com/Stevemoretz | @Stevemoretz}.\n * \n * <h2>Usage:</h2>\n *\n * Install the package\n```sh\nnpm i ssr-only-secrets\n```\n * \n * Generate a jwk-formatted AES-CBC key, e.g. by running\n```js\ncrypto.subtle\n  .generateKey(\n    {\n      name: \"AES-CBC\",\n      length: 256,\n    },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  )\n  .then((key) => crypto.subtle.exportKey(\"jwk\", key))\n  .then(JSON.stringify)\n  .then(console.log);\n```\n * and store the result in an environment variable, e.g. `SECRET_KEY_VAR`, e.g. by \n * writing it into your `.env.local`.\n```env\nSECRET_KEY_VAR={\"alg\":\"A256CBC\",\"ext\":true,\"k\":\"...\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}\n```\n *\n * Now, you can pass \"cloaked secrets\" from your Server Components into the\n * SSR-run of your Client Components, without them being accessible in your\n * Client Components in the browser.\n * \n * @example\n * In a Server Component:\n```jsx\nimport { cloakSSROnlySecret } from \"ssr-only-secrets\";\n\nconst MyServerComponent = () => {\n    const secretValue = \"my secret value\"\n    return <ClientComponent ssrOnlySecret={cloakSSROnlySecret(secretValue, \"SECRET_KEY_VAR\")} />\n}\n```\n * And in a Client Component\n```jsx\nimport { useSSROnlySecret } from \"ssr-only-secrets\";\n\nconst ClientComponent = ({ssrOnlySecret}, \"SECRET_KEY_VAR\") => {\n    const value = useSSROnlySecret(ssrOnlySecret);\n    console.log(value); // during SSR, this logs \"my secret value\", but in the browser, it logs \"undefined\"\n}\n```\n  * Alternatively, you can decrypt the secret in your code by calling `readSSROnlySecret`, e.g. in an Apollo Link:\n```jsx\nconst value = await readSSROnlySecret(ssrOnlySecret)\n```\n@packageDocumentation\n */\n/**\n * @internal\n */\nexport const _ = undefined;\nexport * from \"./ssr.js\";\nexport * from \"./rsc.js\";\n","import { wrap } from \"optimism\";\nimport { deserialize, getEncryptionKey } from \"./shared.js\";\nimport { use } from \"react\";\n\n/**\n * Decrypts a secret that was created in a Server Component using\n * `cloakSSROnlySecret`.\n *\n * Calling this in a Browser environment will always return `undefined`.\n *\n * Only available in Client Components.\n *\n * @public\n */\nexport async function readSSROnlySecret(\n  cloakedSecret: string | undefined,\n  encryptionEnvVarName: string\n): Promise<string | undefined> {\n  if (cloakedSecret == undefined) {\n    return undefined;\n  }\n  const key = await getEncryptionKey(encryptionEnvVarName);\n  const [crypt, iv] = deserialize(cloakedSecret);\n\n  const decrypted = await crypto.subtle.decrypt(\n    {\n      name: \"AES-CBC\",\n      iv: iv,\n    },\n    key,\n    crypt\n  );\n\n  return new TextDecoder().decode(decrypted);\n}\n\n/**\n * We need to memoize the promises returned from `readSSROnlySecret` to avoid\n * an infinite render circle with `use`.\n * We use the `optimism` package for this.\n * We assume that `10000` is a reasonable maximum number of secrets that will be\n * read simultaneously, but this value might need increasing in the future depending\n * on how this is used.\n */\nconst memoizedReadSSROnlySecret = wrap(readSSROnlySecret, {\n  max: 10000,\n}) as any as typeof readSSROnlySecret;\n\n/**\n * Decrypts a secret that was created in a Server Component using\n * `cloakSSROnlySecret`.\n * If called during SSR, this hook will briefly suspend your component and\n * then return the decrypted secret.\n *\n * Calling this in a Browser environment will always return `undefined`.\n *\n * Only available in Client Components.\n *\n * @public\n */\nexport function useSSROnlySecret(\n  cloakedSecret: string | undefined,\n  encryptionEnvVarName: string\n): string | undefined {\n  const promise = memoizedReadSSROnlySecret(\n    cloakedSecret,\n    encryptionEnvVarName\n  );\n  return use(promise);\n}\n","export function getEncryptionKey(envVarName: string): Promise<CryptoKey> {\n  if (envVarName == undefined) {\n    throw new Error(\n      \"You need to specify the name for a secret-holding environment variable.\"\n    );\n  }\n  if (envVarName.startsWith(\"NEXT_PUBLIC_\")) {\n    throw new Error(\n      \"You cannot use NEXT_PUBLIC_ environment variables for secrets, as they would be transported to the browser.\"\n    );\n  }\n  const encryption_key = process.env[envVarName];\n  if (!encryption_key) {\n    throw new Error(\n      \"There is no environment variable named \" + envVarName + \".\"\n    );\n  }\n  let parsed: JsonWebKey;\n  try {\n    const buffer = Buffer.from(encryption_key, \"base64\");\n    const decodedKey = buffer.toString(\"utf8\");\n    parsed = JSON.parse(decodedKey);\n  } catch {\n    throw new Error(\n      \"The environment variable \" +\n        envVarName +\n        \" does not contain a valid JSON string.\"\n    );\n  }\n  return crypto.subtle.importKey(\"jwk\", parsed, \"AES-CBC\", false, [\n    \"encrypt\",\n    \"decrypt\",\n  ]);\n}\n\nexport function serialize(crypt: ArrayBuffer, iv: Uint8Array) {\n  return (\n    Buffer.from(crypt).toString(\"base64\") +\n    \":\" +\n    Buffer.from(iv).toString(\"base64\")\n  );\n}\n\nexport function deserialize(serialized: string) {\n  const [crypt, iv] = serialized.split(\":\");\n  return [\n    Buffer.from(crypt, \"base64\"),\n    Uint8Array.from(Buffer.from(iv, \"base64\")),\n  ] as const;\n}\n","import { experimental_taintUniqueValue } from \"react\";\nimport { getEncryptionKey, serialize } from \"./shared.js\";\n\ndeclare module \"react\" {\n  type TypedArray =\n    | Int8Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n    | BigInt64Array\n    | BigUint64Array;\n  export const experimental_taintUniqueValue:\n    | undefined\n    | ((\n        message: string,\n        lifetime: object,\n        value: string | bigint | TypedArray\n      ) => void);\n}\n\n/**\n * Encrypts a secret so that it can be passed from Server Components into the\n * SSR-run of Client Components without them being accessible in the browser.\n *\n * Use `useSSROnlySecret` or `readSSROnlySecret` to decrypt the secret in your\n * Client Component.\n *\n * Only available in Server Components.\n *\n * @public\n */\nexport async function cloakSSROnlySecret(\n  secret: string,\n  encryptionEnvVarName: string\n) {\n  if (experimental_taintUniqueValue) {\n    experimental_taintUniqueValue(\n      `Do not pass the content of the envrionment variable \"${encryptionEnvVarName}\" directly into client component props. This is unsafe!`,\n      process,\n      secret\n    );\n  }\n\n  const key = await getEncryptionKey(encryptionEnvVarName);\n  const encoded = new TextEncoder().encode(secret);\n\n  const iv = crypto.getRandomValues(new Uint8Array(16));\n  const crypt = crypto.subtle.encrypt(\n    {\n      name: \"AES-CBC\",\n      iv: iv,\n    },\n    key,\n    encoded\n  );\n\n  return serialize(await crypt, iv);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,sBAAqB;;;ACAd,SAAS,iBAAiB,YAAwC;AACvE,MAAI,cAAc,QAAW;AAC3B,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,MAAI,WAAW,WAAW,cAAc,GAAG;AACzC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,iBAAiB,QAAQ,IAAI,UAAU;AAC7C,MAAI,CAAC,gBAAgB;AACnB,UAAM,IAAI;AAAA,MACR,4CAA4C,aAAa;AAAA,IAC3D;AAAA,EACF;AACA,MAAI;AACJ,MAAI;AACF,UAAM,SAAS,OAAO,KAAK,gBAAgB,QAAQ;AACnD,UAAM,aAAa,OAAO,SAAS,MAAM;AACzC,aAAS,KAAK,MAAM,UAAU;AAAA,EAChC,QAAQ;AACN,UAAM,IAAI;AAAA,MACR,8BACE,aACA;AAAA,IACJ;AAAA,EACF;AACA,SAAO,OAAO,OAAO,UAAU,OAAO,QAAQ,WAAW,OAAO;AAAA,IAC9D;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAEO,SAAS,UAAU,OAAoB,IAAgB;AAC5D,SACE,OAAO,KAAK,KAAK,EAAE,SAAS,QAAQ,IACpC,MACA,OAAO,KAAK,EAAE,EAAE,SAAS,QAAQ;AAErC;AAEO,SAAS,YAAY,YAAoB;AAC9C,QAAM,CAAC,OAAO,EAAE,IAAI,WAAW,MAAM,GAAG;AACxC,SAAO;AAAA,IACL,OAAO,KAAK,OAAO,QAAQ;AAAA,IAC3B,WAAW,KAAK,OAAO,KAAK,IAAI,QAAQ,CAAC;AAAA,EAC3C;AACF;;;AD/CA,mBAAoB;AAYpB,eAAsB,kBACpB,eACA,sBAC6B;AAC7B,MAAI,iBAAiB,QAAW;AAC9B,WAAO;AAAA,EACT;AACA,QAAM,MAAM,MAAM,iBAAiB,oBAAoB;AACvD,QAAM,CAAC,OAAO,EAAE,IAAI,YAAY,aAAa;AAE7C,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IACpC;AAAA,MACE,MAAM;AAAA,MACN;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,IAAI,YAAY,EAAE,OAAO,SAAS;AAC3C;AAUA,IAAM,gCAA4B,sBAAK,mBAAmB;AAAA,EACxD,KAAK;AACP,CAAC;AAcM,SAAS,iBACd,eACA,sBACoB;AACpB,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,EACF;AACA,aAAO,kBAAI,OAAO;AACpB;;;AErEA,IAAAA,gBAA8C;AAoC9C,eAAsB,mBACpB,QACA,sBACA;AACA,MAAI,6CAA+B;AACjC;AAAA,MACE,wDAAwD,oBAAoB;AAAA,MAC5E;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,MAAM,MAAM,iBAAiB,oBAAoB;AACvD,QAAM,UAAU,IAAI,YAAY,EAAE,OAAO,MAAM;AAE/C,QAAM,KAAK,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC;AACpD,QAAM,QAAQ,OAAO,OAAO;AAAA,IAC1B;AAAA,MACE,MAAM;AAAA,MACN;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO,UAAU,MAAM,OAAO,EAAE;AAClC;;;AHIO,IAAM,IAAI;","names":["import_react"]}